{"ast":null,"code":"import hash from 'object-hash';\n\nconst createHashArray = s => {\n  return s.split(\" \").map(word => hash(word));\n};\n\nconst calculateEditDistance = (incoming, expected) => {\n  if (incoming.length === 0 || expected.length === 0) return Math.max(incoming.split(\" \").length, expected.split(\" \").length);\n  let [incomingHashes, expectedHashes] = [createHashArray(incoming), createHashArray(expected)];\n  let [length, height] = [incomingHashes.length, expectedHashes.length];\n  let dp = initializeArray(height, length);\n\n  for (let column = 0; column < height; column++) {\n    for (let row = 0; row < length; row++) {\n      if (column === 0 && row === 0) {\n        dp[column][row] = incomingHashes[0] === expectedHashes[0] ? 0 : 1;\n      } else if (row === 0) {\n        dp[column][row] = dp[column - 1][0] + (incomingHashes[row] === expectedHashes[column] ? 0 : 1);\n      } else if (column === 0) {\n        dp[column][row] = dp[0][row - 1] + (incomingHashes[row] === expectedHashes[column] ? 0 : 1);\n      } else {\n        dp[column][row] = Math.min(dp[column - 1][row] + 1, dp[column][row - 1] + 1, dp[column - 1][row - 1] + (incomingHashes[row] === expectedHashes[column] ? 0 : 1));\n      }\n    }\n  }\n\n  return dp[height - 1][length - 1];\n};\n\nconst initializeArray = (length, height) => {\n  let dp = [];\n\n  for (let i = 0; i < length; i++) {\n    dp.push([]);\n\n    for (let j = 0; j < height; j++) {\n      dp[i].push(-1);\n    }\n  }\n\n  return dp;\n};\n\nexport const wordErrorRate = (incoming, expected) => {\n  const editDistance = calculateEditDistance(incoming, expected);\n  const score = editDistance / Math.max(incoming.split(\" \").length, expected.split(\" \").length);\n  return score;\n};","map":{"version":3,"sources":["/app/src/utils/wer.js"],"names":["hash","createHashArray","s","split","map","word","calculateEditDistance","incoming","expected","length","Math","max","incomingHashes","expectedHashes","height","dp","initializeArray","column","row","min","i","push","j","wordErrorRate","editDistance","score"],"mappings":"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","sourcesContent":["import hash from 'object-hash';\n\nconst createHashArray = (s) => {\n  return s.split(\" \").map(word => hash(word));\n}\n\nconst calculateEditDistance = (incoming, expected) => {\n  if (incoming.length === 0 || expected.length === 0) return Math.max(incoming.split(\" \").length, expected.split(\" \").length);\n\n  let [incomingHashes, expectedHashes] = [createHashArray(incoming), createHashArray(expected)];\n  let [length, height] = [incomingHashes.length, expectedHashes.length];\n\n  let dp = initializeArray(height, length);\n\n  for (let column = 0; column < height; column++) {\n    for (let row = 0; row < length; row++) {\n      if (column === 0 && row === 0) {\n        dp[column][row] = (incomingHashes[0] === expectedHashes[0]) ? 0 : 1;\n      } else if (row === 0) {\n        dp[column][row] = dp[column - 1][0] + ((incomingHashes[row] === expectedHashes[column]) ? 0 : 1);\n      } else if (column === 0) {\n        dp[column][row] = dp[0][row - 1] + ((incomingHashes[row] === expectedHashes[column]) ? 0 : 1);\n      } else {\n        dp[column][row] =\n          Math.min(\n            (dp[column - 1][row] + 1),\n            (dp[column][row - 1] + 1),\n            (dp[column - 1][row - 1] + (incomingHashes[row] === expectedHashes[column] ? 0 : 1))\n          )\n      }\n    }\n  }\n  return dp[height - 1][length - 1];\n}\n\nconst initializeArray = (length, height) => {\n  let dp = [];\n  for (let i = 0; i < length; i++) {\n    dp.push([]);\n    for (let j = 0; j < height; j++) {\n      dp[i].push(-1);\n    }\n  }\n  return dp;\n}\n\nexport const wordErrorRate = (incoming, expected) => {\n  const editDistance = calculateEditDistance(incoming, expected);\n  const score = editDistance / Math.max(incoming.split(\" \").length, expected.split(\" \").length);\n  return score;\n}"]},"metadata":{},"sourceType":"module"}